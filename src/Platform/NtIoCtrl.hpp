
//------------------------------------------------------------------------------------------------------------
constexpr static _finline DWORD CTL_CODE(DWORD DeviceType, DWORD Function, DWORD Method, DWORD Access) { return (DeviceType << 16) | (Access << 14) | (Function << 2) | Method; }
constexpr static _finline DWORD DEVICE_TYPE_FROM_CTL_CODE(DWORD ctrlCode) { return (((DWORD)(ctrlCode & 0xffff0000)) >> 16); }   // Macro to extract device type out of the device io control code
constexpr static _finline DWORD METHOD_FROM_CTL_CODE(DWORD ctrlCode) { return ((DWORD)(ctrlCode & 3)); }  // Macro to extract buffering method out of the device io control code

enum EIOMETHD: DWORD
{
 METHOD_BUFFERED   = 0,
 METHOD_IN_DIRECT  = 1,
 METHOD_OUT_DIRECT = 2,
 METHOD_NEITHER    = 3,
};

enum EFACCESS: DWORD
{
 FILE_ANY_ACCESS      = 0,
 FILE_SPECIAL_ACCESS  = FILE_ANY_ACCESS,
 FILE_READ_ACCESS     = FILE_READ_DATA,    // file & pipe
 FILE_WRITE_ACCESS    = FILE_WRITE_DATA,   // file & pipe
};

enum EFDEVS: DWORD
{
 FILE_DEVICE_BEEP                = 0x00000001,
 FILE_DEVICE_CD_ROM              = 0x00000002,
 FILE_DEVICE_CD_ROM_FILE_SYSTEM  = 0x00000003,
 FILE_DEVICE_CONTROLLER          = 0x00000004,
 FILE_DEVICE_DATALINK            = 0x00000005,
 FILE_DEVICE_DFS                 = 0x00000006,
 FILE_DEVICE_DISK                = 0x00000007,
 FILE_DEVICE_DISK_FILE_SYSTEM    = 0x00000008,
 FILE_DEVICE_FILE_SYSTEM         = 0x00000009,
 FILE_DEVICE_INPORT_PORT         = 0x0000000a,
 FILE_DEVICE_KEYBOARD            = 0x0000000b,
 FILE_DEVICE_MAILSLOT            = 0x0000000c,
 FILE_DEVICE_MIDI_IN             = 0x0000000d,
 FILE_DEVICE_MIDI_OUT            = 0x0000000e,
 FILE_DEVICE_MOUSE               = 0x0000000f,
 FILE_DEVICE_MULTI_UNC_PROVIDER  = 0x00000010,
 FILE_DEVICE_NAMED_PIPE          = 0x00000011,
 FILE_DEVICE_NETWORK             = 0x00000012,
 FILE_DEVICE_NETWORK_BROWSER     = 0x00000013,
 FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014,
 FILE_DEVICE_NULL                = 0x00000015,
 FILE_DEVICE_PARALLEL_PORT       = 0x00000016,
 FILE_DEVICE_PHYSICAL_NETCARD    = 0x00000017,
 FILE_DEVICE_PRINTER             = 0x00000018,
 FILE_DEVICE_SCANNER             = 0x00000019,
 FILE_DEVICE_SERIAL_MOUSE_PORT   = 0x0000001a,
 FILE_DEVICE_SERIAL_PORT         = 0x0000001b,
 FILE_DEVICE_SCREEN              = 0x0000001c,
 FILE_DEVICE_SOUND               = 0x0000001d,
 FILE_DEVICE_STREAMS             = 0x0000001e,
 FILE_DEVICE_TAPE                = 0x0000001f,
 FILE_DEVICE_TAPE_FILE_SYSTEM    = 0x00000020,
 FILE_DEVICE_TRANSPORT           = 0x00000021,
 FILE_DEVICE_UNKNOWN             = 0x00000022,
 FILE_DEVICE_VIDEO               = 0x00000023,
 FILE_DEVICE_VIRTUAL_DISK        = 0x00000024,
 FILE_DEVICE_WAVE_IN             = 0x00000025,
 FILE_DEVICE_WAVE_OUT            = 0x00000026,
 FILE_DEVICE_8042_PORT           = 0x00000027,
 FILE_DEVICE_NETWORK_REDIRECTOR  = 0x00000028,
 FILE_DEVICE_BATTERY             = 0x00000029,
 FILE_DEVICE_BUS_EXTENDER        = 0x0000002a,
 FILE_DEVICE_MODEM               = 0x0000002b,
 FILE_DEVICE_VDM                 = 0x0000002c,
 FILE_DEVICE_MASS_STORAGE        = 0x0000002d,
 FILE_DEVICE_SMB                 = 0x0000002e,
 FILE_DEVICE_KS                  = 0x0000002f,
 FILE_DEVICE_CHANGER             = 0x00000030,
 FILE_DEVICE_SMARTCARD           = 0x00000031,
 FILE_DEVICE_ACPI                = 0x00000032,
 FILE_DEVICE_DVD                 = 0x00000033,
 FILE_DEVICE_FULLSCREEN_VIDEO    = 0x00000034,
 FILE_DEVICE_DFS_FILE_SYSTEM     = 0x00000035,
 FILE_DEVICE_DFS_VOLUME          = 0x00000036,
 FILE_DEVICE_SERENUM             = 0x00000037,
 FILE_DEVICE_TERMSRV             = 0x00000038,
 FILE_DEVICE_KSEC                = 0x00000039,
 FILE_DEVICE_FIPS                = 0x0000003A,
 FILE_DEVICE_INFINIBAND          = 0x0000003B,
 FILE_DEVICE_VMBUS               = 0x0000003E,
 FILE_DEVICE_CRYPT_PROVIDER      = 0x0000003F,
 FILE_DEVICE_WPD                 = 0x00000040,
 FILE_DEVICE_BLUETOOTH           = 0x00000041,
 FILE_DEVICE_MT_COMPOSITE        = 0x00000042,
 FILE_DEVICE_MT_TRANSPORT        = 0x00000043,
 FILE_DEVICE_BIOMETRIC		     = 0x00000044,
 FILE_DEVICE_PMI                 = 0x00000045,
};

//enum EIOCTL: DWORD      // winioctl.h        // Dumb C++ forbids to see the CTL_CODE function in this enum. At least it can 'see' it in direct members because the NNTDLL class is a template
//{
// IoControlCode values for disk devices
SCVR DWORD IOCTL_DISK_BASE                 = FILE_DEVICE_DISK;
SCVR DWORD IOCTL_DISK_GET_DRIVE_GEOMETRY   = CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_GET_PARTITION_INFO   = CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_LAYOUT     = CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_REQUEST_DATA         = CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_IS_WRITABLE          = CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_DISK_CONTROLLER_NUMBER    = CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS);

// IOCTL support for SMART drive fault prediction
SCVR DWORD SMART_GET_VERSION               = CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD SMART_SEND_DRIVE_COMMAND        = CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD SMART_RCV_DRIVE_DATA            = CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

// New IOCTLs for GUID Partition tabled disks
SCVR DWORD IOCTL_DISK_GET_PARTITION_INFO_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_SET_PARTITION_INFO_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_LAYOUT_EX      = CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_DISK_SET_DRIVE_LAYOUT_EX      = CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_CREATE_DISK              = CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_DISK_GET_LENGTH_INFO          = CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_DRIVE_GEOMETRY_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS);

// The following device control codes are common for all class drivers.
SCVR DWORD IOCTL_DISK_CHECK_VERIFY     = CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_MEDIA_REMOVAL    = CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_EJECT_MEDIA      = CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_LOAD_MEDIA       = CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_RESERVE          = CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_RELEASE          = CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_FIND_NEW_DEVICES = CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_DISK_GET_MEDIA_TYPES  = CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_STORAGE_BASE = FILE_DEVICE_MASS_STORAGE;
// The following device control codes are common for all class drivers. They should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE common codes

SCVR DWORD IOCTL_STORAGE_CHECK_VERIFY            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_CHECK_VERIFY2           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_MEDIA_REMOVAL           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_EJECT_MEDIA             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_LOAD_MEDIA              = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_LOAD_MEDIA2             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_RESERVE                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_RELEASE                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_FIND_NEW_DEVICES        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS);

SCVR DWORD IOCTL_STORAGE_EJECTION_CONTROL        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_MCN_CONTROL             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD IOCTL_STORAGE_GET_MEDIA_TYPES         = CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_MEDIA_TYPES_EX      = CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_GET_HOTPLUG_INFO        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_SET_HOTPLUG_INFO        = CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_STORAGE_RESET_BUS               = CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_RESET_DEVICE            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_BREAK_RESERVATION       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_PERSISTENT_RESERVE_IN   = CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS);
SCVR DWORD IOCTL_STORAGE_PERSISTENT_RESERVE_OUT  = CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_STORAGE_GET_DEVICE_NUMBER       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD IOCTL_STORAGE_PREDICT_FAILURE         = CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS);


SCVR DWORD IOCTL_VOLUME_BASE                     = 0x00000056; 

// IOCTL to obtain the physical location of the specified volume on one or more disks.
SCVR DWORD IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS  = CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS);

// IOCTLs to transition the specified volume between r/w and non r/w modes.
SCVR DWORD IOCTL_VOLUME_ONLINE                   = CTL_CODE(IOCTL_VOLUME_BASE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
SCVR DWORD IOCTL_VOLUME_OFFLINE                  = CTL_CODE(IOCTL_VOLUME_BASE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

SCVR DWORD IOCTL_VOLUME_GET_GPT_ATTRIBUTES       = CTL_CODE(IOCTL_VOLUME_BASE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS);

// The following is a list of the native file system fsctls followed by additional network file system fsctls.  Some values have been decommissioned.
SCVR DWORD FSCTL_LOCK_VOLUME               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_UNLOCK_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DISMOUNT_VOLUME           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS);
                               
SCVR DWORD FSCTL_IS_VOLUME_MOUNTED         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_IS_PATHNAME_VALID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS); // PATHNAME_BUFFER,
SCVR DWORD FSCTL_MARK_VOLUME_DIRTY         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                
SCVR DWORD FSCTL_QUERY_RETRIEVAL_POINTERS  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_GET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA);
                             
SCVR DWORD FSCTL_SET_BOOTLOADER_ACCESSED   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_OPLOCK_BREAK_ACK_NO_2     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_INVALIDATE_VOLUMES        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_QUERY_FAT_BPB             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS); // FSCTL_QUERY_FAT_BPB_BUFFER
SCVR DWORD FSCTL_REQUEST_FILTER_OPLOCK     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_FILESYSTEM_GET_STATISTICS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILESYSTEM_STATISTICS
                              
SCVR DWORD FSCTL_GET_NTFS_VOLUME_DATA      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS); // NTFS_VOLUME_DATA_BUFFER
SCVR DWORD FSCTL_GET_NTFS_FILE_RECORD      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS); // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
SCVR DWORD FSCTL_GET_VOLUME_BITMAP         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS); // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
SCVR DWORD FSCTL_GET_RETRIEVAL_POINTERS    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS); // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
SCVR DWORD FSCTL_MOVE_FILE                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // MOVE_FILE_DATA,
SCVR DWORD FSCTL_IS_VOLUME_DIRTY           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS);
                              
SCVR DWORD FSCTL_FIND_FILES_BY_SID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS);
                               
SCVR DWORD FSCTL_SET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_GET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_DELETE_OBJECT_ID          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // REPARSE_DATA_BUFFER,
SCVR DWORD FSCTL_GET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS); // REPARSE_DATA_BUFFER
SCVR DWORD FSCTL_DELETE_REPARSE_POINT      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // REPARSE_DATA_BUFFER,
SCVR DWORD FSCTL_ENUM_USN_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS); // MFT_ENUM_DATA,
SCVR DWORD FSCTL_SECURITY_ID_CHECK         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA);  // BULK_SECURITY_TEST_DATA,
SCVR DWORD FSCTL_READ_USN_JOURNAL          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS); // READ_USN_JOURNAL_DATA, USN
SCVR DWORD FSCTL_SET_OBJECT_ID_EXTENDED    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_CREATE_OR_GET_OBJECT_ID   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS); // FILE_OBJECTID_BUFFER
SCVR DWORD FSCTL_SET_SPARSE                = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_ZERO_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA); // FILE_ZERO_DATA_INFORMATION,
SCVR DWORD FSCTL_QUERY_ALLOCATED_RANGES    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA);  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
SCVR DWORD FSCTL_ENABLE_UPGRADE            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA);

SCVR DWORD FSCTL_SET_ENCRYPTION            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS); // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
SCVR DWORD FSCTL_ENCRYPTION_FSCTL_IO       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_WRITE_RAW_ENCRYPTED       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS); // ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
SCVR DWORD FSCTL_READ_RAW_ENCRYPTED        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS); // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
SCVR DWORD FSCTL_CREATE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS); // CREATE_USN_JOURNAL_DATA,
SCVR DWORD FSCTL_READ_FILE_USN_DATA        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS); // Read the Usn Record for a file
SCVR DWORD FSCTL_WRITE_USN_CLOSE_RECORD    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS); // Generate Close Usn Record
SCVR DWORD FSCTL_EXTEND_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_QUERY_USN_JOURNAL         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DELETE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_MARK_HANDLE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SIS_COPYFILE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SIS_LINK_FILES            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA);
                               
SCVR DWORD FSCTL_RECALL_FILE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_READ_FROM_PLEX            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA);
SCVR DWORD FSCTL_FILE_PREFETCH             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // FILE_PREFETCH

SCVR DWORD FSCTL_MAKE_MEDIA_COMPATIBLE         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA); // UDFS R/W
SCVR DWORD FSCTL_SET_DEFECT_MANAGEMENT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA); // UDFS R/W
SCVR DWORD FSCTL_QUERY_SPARING_INFO            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS); // UDFS R/W
SCVR DWORD FSCTL_QUERY_ON_DISK_VOLUME_INFO     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS); // C/UDFS
SCVR DWORD FSCTL_SET_VOLUME_COMPRESSION_STATE  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // VOLUME_COMPRESSION_STATE
                               
SCVR DWORD FSCTL_SET_ZERO_ON_DEALLOCATION      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);
SCVR DWORD FSCTL_SET_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_GET_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_WAIT_FOR_REPAIR               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS);

SCVR DWORD FSCTL_INITIATE_REPAIR               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_CSC_INTERNAL                  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS); // CSC internal implementation
SCVR DWORD FSCTL_SHRINK_VOLUME                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS); // SHRINK_VOLUME_INFORMATION
SCVR DWORD FSCTL_SET_SHORT_NAME_BEHAVIOR       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_DFSR_SET_GHOST_HANDLE_STATE   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                    
SCVR DWORD FSCTL_QUERY_PAGEFILE_ENCRYPTION     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_RESET_VOLUME_ALLOCATION_HINTS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_SD_GLOBAL_CHANGE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS); // Update NTFS Security Descriptors
SCVR DWORD FSCTL_LOOKUP_STREAM_FROM_CLUSTER    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS);
SCVR DWORD FSCTL_FILE_TYPE_NOTIFICATION        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS);
                                    
SCVR DWORD FSCTL_GET_BOOT_AREA_INFO            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS);  // BOOT_AREA_INFO
SCVR DWORD FSCTL_GET_RETRIEVAL_POINTER_BASE    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS);  // RETRIEVAL_POINTER_BASE
SCVR DWORD FSCTL_SET_PERSISTENT_VOLUME_STATE   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS);  // FILE_FS_PERSISTENT_VOLUME_INFORMATION
SCVR DWORD FSCTL_QUERY_PERSISTENT_VOLUME_STATE = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS);  // FILE_FS_PERSISTENT_VOLUME_INFORMATION


//};

enum MEDIA_TYPE 
{
 Unknown,                // Format is unknown
 F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
 F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
 F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
 F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
 F3_720_512,             // 3.5",  720KB,  512 bytes/sector
 F5_360_512,             // 5.25", 360KB,  512 bytes/sector
 F5_320_512,             // 5.25", 320KB,  512 bytes/sector
 F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
 F5_180_512,             // 5.25", 180KB,  512 bytes/sector
 F5_160_512,             // 5.25", 160KB,  512 bytes/sector
 RemovableMedia,         // Removable media other than floppy
 FixedMedia,             // Fixed hard disk media
 F3_120M_512,            // 3.5", 120M Floppy
 F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
 F5_640_512,             // 5.25",  640KB,  512 bytes/sector
 F5_720_512,             // 5.25",  720KB,  512 bytes/sector
 F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
 F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
 F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
 F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
 F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
 F8_256_128,             // 8",     256KB,  128 bytes/sector
 F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
 F3_240M_512,            // 3.5",   240Mb Floppy (HiFD)
 F3_32M_512              // 3.5",   32Mb Floppy
};

enum PARTITION_STYLE 
{
 PARTITION_STYLE_MBR,
 PARTITION_STYLE_GPT,
 PARTITION_STYLE_RAW
};

// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES request.
struct DISK_GEOMETRY 
{
 LARGE_INTEGER Cylinders;
 MEDIA_TYPE MediaType;
 DWORD TracksPerCylinder;
 DWORD SectorsPerTrack;
 DWORD BytesPerSector;
};

struct DISK_GEOMETRY_EX      // IOCTL_DISK_GET_DRIVE_GEOMETRY_EX IOCTL
{
  DISK_GEOMETRY Geometry;
  LARGE_INTEGER DiskSize;
  BYTE          Data[1];
};

// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
struct PARTITION_INFORMATION 
{
 LARGE_INTEGER StartingOffset;
 LARGE_INTEGER PartitionLength;
 DWORD HiddenSectors;
 DWORD PartitionNumber;
 BYTE  PartitionType;
 BOOLEAN BootIndicator;
 BOOLEAN RecognizedPartition;
 BOOLEAN RewritePartition;
};

// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
struct DRIVE_LAYOUT_INFORMATION 
{
  DWORD PartitionCount;
  DWORD Signature;
  PARTITION_INFORMATION PartitionEntry[1];
};

// The following structure defines information in a GPT partition that is not common to both GPT and MBR partitions.
struct PARTITION_INFORMATION_GPT 
{
 GUID  PartitionType;                 // Partition type. See table 16-3.
 GUID  PartitionId;                   // Unique GUID for this partition.
 QWORD Attributes;                 // See table 16-4.
 WCHAR Name [36];                    // Partition Name in Unicode.
};

// The following structure defines information in an MBR partition that is not common to both GPT and MBR partitions.
struct PARTITION_INFORMATION_MBR 
{
 BYTE  PartitionType;
 BOOLEAN BootIndicator;
 BOOLEAN RecognizedPartition;
 DWORD HiddenSectors;
};

// GPT specific drive layout information.
struct DRIVE_LAYOUT_INFORMATION_GPT 
{
 GUID DiskId;
 LARGE_INTEGER StartingUsableOffset;
 LARGE_INTEGER UsableLength;
 DWORD MaxPartitionCount;
};

// MBR specific drive layout information.
struct DRIVE_LAYOUT_INFORMATION_MBR 
{
 DWORD Signature;
};

// The structure GET_LENGTH_INFORMATION is used with the ioctl IOCTL_DISK_GET_LENGTH_INFO to obtain the length, in bytes, of the disk, partition, or volume.
struct GET_LENGTH_INFORMATION 
{
 LARGE_INTEGER Length;
};

// The PARTITION_INFORMATION_EX structure is used with the IOCTL_DISK_GET_DRIVE_LAYOUT_EX, IOCTL_DISK_SET_DRIVE_LAYOUT_EX, IOCTL_DISK_GET_PARTITION_INFO_EX and IOCTL_DISK_GET_PARTITION_INFO_EX calls.
struct PARTITION_INFORMATION_EX 
{
  PARTITION_STYLE PartitionStyle;
  LARGE_INTEGER StartingOffset;
  LARGE_INTEGER PartitionLength;
  DWORD   PartitionNumber;
  BOOLEAN RewritePartition;
  union {
      PARTITION_INFORMATION_MBR Mbr;
      PARTITION_INFORMATION_GPT Gpt;
  } DUMMYUNIONNAME;
};

// The structure DRIVE_LAYOUT_INFORMATION_EX is used with the IOCTL_SET_DRIVE_LAYOUT_EX and IOCTL_GET_DRIVE_LAYOUT_EX calls.
struct DRIVE_LAYOUT_INFORMATION_EX 
{
 DWORD PartitionStyle;
 DWORD PartitionCount;
 union {
     DRIVE_LAYOUT_INFORMATION_MBR Mbr;
     DRIVE_LAYOUT_INFORMATION_GPT Gpt;
 } DUMMYUNIONNAME;
 PARTITION_INFORMATION_EX PartitionEntry[1];
};

// The DISK_GEOMETRY_EX structure is returned on issuing an IOCTL_DISK_GET_DRIVE_GEOMETRY_EX ioctl.
enum DETECTION_TYPE 
{
 DetectNone,
 DetectInt13,
 DetectExInt13
};

struct DISK_INT13_INFO 
{
 WORD   DriveSelect;
 DWORD  MaxCylinders;
 WORD   SectorsPerTrack;
 WORD   MaxHeads;
 WORD   NumberDrives;
};

struct DISK_EX_INT13_INFO 
{
 WORD   ExBufferSize;
 WORD   ExFlags;
 DWORD  ExCylinders;
 DWORD  ExHeads;
 DWORD  ExSectorsPerTrack;
 QWORD  ExSectorsPerDrive;
 WORD   ExSectorSize;
 WORD   ExReserved;
};

// The values in the STORAGE_DEVICE_NUMBER structure are guaranteed to remain unchanged until the system is rebooted.  They are not guaranteed to be persistant across boots.
struct STORAGE_DEVICE_NUMBER 
{
 DWORD  DeviceType;        // The FILE_DEVICE_XXX type for this device.  // DEVICE_TYPE
 DWORD  DeviceNumber;      // The number of this device
 DWORD  PartitionNumber;   // If the device is partitionable, the partition number of the device. Otherwise -1
};


struct DISK_EXTENT   // IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
{
 DWORD DiskNumber;     // Specifies the storage device number of the disk on which this extent resides.
 LARGE_INTEGER StartingOffset;    // Specifies the offset and length of this extent relative to the beginning of the disk.
 LARGE_INTEGER ExtentLength;
};

template<int N> struct VOLUME_DISK_EXTENTS 
{
 DWORD NumberOfDiskExtents;    // Specifies one or more contiguous range of sectors that make up this volume.
 DISK_EXTENT Extents[N];
};
//------------------------------------------------------------------------------------------------------------
//============================================================================================================
// A clear operation is valid only on files that no longer have any sparse regions. 
//Performing a clear operation on a file with sparse regions can have unpredictable results. 
//You can determine whether there are any sparse regions in a file by using the FSCTL_QUERY_ALLOCATED_RANGES control code.
struct FILE_SET_SPARSE_BUFFER    
{
 BOOLEAN SetSparse;
};

struct FILE_ZERO_DATA_INFORMATION    // Structure for FSCTL_SET_ZERO_DATA
{
 LARGE_INTEGER FileOffset;
 LARGE_INTEGER BeyondFinalZero;
};
//------------------------------------------------------------------------------------------------------------

// https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_reparse_data_buffer
// https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/b41f1cbf-10df-4a47-98d4-1c52a833d913
// https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntioapi.h
// Reparse structure for FSCTL_SET_REPARSE_POINT, FSCTL_GET_REPARSE_POINT, FSCTL_DELETE_REPARSE_POINT


enum ESymlnkFlags
{
 SYMLINK_FILE          = 0x40000000, // If set then this is a file symlink
 SYMLINK_DIRECTORY     = 0x80000000, // If set then this is a directory symlink
 SYMLINK_FLAG_RELATIVE = 0x00000001,
};

struct REPARSE_DATA_BUFFER 
{
 ULONG  ReparseTag;
 USHORT ReparseDataLength;
 USHORT Reserved;
 union {
 	struct {
 		USHORT SubstituteNameOffset;
 		USHORT SubstituteNameLength;
 		USHORT PrintNameOffset;
 		USHORT PrintNameLength;
 		ULONG  Flags;
 		WCHAR  PathBuffer[1];
 	} SymbolicLinkReparseBuffer;
 	struct {
 		USHORT SubstituteNameOffset;
 		USHORT SubstituteNameLength;
 		USHORT PrintNameOffset;
 		USHORT PrintNameLength;
 		WCHAR  PathBuffer[1];
 	} MountPointReparseBuffer;
 	struct {
 		UCHAR  DataBuffer[1];
 	} GenericReparseBuffer;
 };
};

enum EReparseTag
{
 IO_REPARSE_TAG_MOUNT_POINT      = 0xA0000003,       // winnt
 IO_REPARSE_TAG_HSM              = 0xC0000004,       // winnt
 IO_REPARSE_TAG_DRIVE_EXTENDER   = 0x80000005,
 IO_REPARSE_TAG_HSM2             = 0x80000006,       // winnt
 IO_REPARSE_TAG_SIS              = 0x80000007,       // winnt
 IO_REPARSE_TAG_WIM              = 0x80000008,       // winnt
 IO_REPARSE_TAG_CSV              = 0x80000009,       // winnt
 IO_REPARSE_TAG_DFS              = 0x8000000A,       // winnt
 IO_REPARSE_TAG_FILTER_MANAGER   = 0x8000000B,
 IO_REPARSE_TAG_SYMLINK          = 0xA000000C,       // winnt
 IO_REPARSE_TAG_IIS_CACHE        = 0xA0000010,
 IO_REPARSE_TAG_DFSR             = 0x80000012,       // winnt
 IO_REPARSE_TAG_DEDUP            = 0x80000013,       // winnt
 IO_REPARSE_TAG_APPXSTRM         = 0xC0000014,
 IO_REPARSE_TAG_NFS              = 0x80000014,       // winnt
 IO_REPARSE_TAG_FILE_PLACEHOLDER = 0x80000015,       // winnt
 IO_REPARSE_TAG_DFM              = 0x80000016,
 IO_REPARSE_TAG_WOF              = 0x80000017,       // winnt
};

//#define REPARSE_DATA_BUFFER_HEADER_SIZE  FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
//#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE  ( 16 * 1024 )
//============================================================================================================
//                                             AFD 
//------------------------------------------------------------------------------------------------------------

SCVR DWORD  AFD_TLI_WRITE  = 1;
SCVR DWORD  AFD_TLI_READ   = 2;

// AFD functions
enum EAFD_FUNCS
{
 AFD_BIND                        = 0,
 AFD_CONNECT                     = 1,
 AFD_START_LISTEN                = 2,
 AFD_WAIT_FOR_LISTEN             = 3,
 AFD_ACCEPT                      = 4,
 AFD_RECV                        = 5,
 AFD_RECV_DATAGRAM               = 6,
 AFD_SEND                        = 7,
 AFD_SEND_DATAGRAM               = 8,
 AFD_SELECT                      = 9,
 AFD_DISCONNECT                  = 10,    // AFD_PARTIAL_DISCONNECT
 AFD_GET_SOCK_NAME               = 11,
 AFD_GET_PEER_NAME               = 12,
 AFD_GET_TDI_HANDLES             = 13,
 AFD_SET_INFO                    = 14,
 AFD_GET_CONTEXT_SIZE            = 15,
 AFD_GET_CONTEXT                 = 16,
 AFD_SET_CONTEXT                 = 17,
 AFD_SET_CONNECT_DATA            = 18,
 AFD_SET_CONNECT_OPTIONS         = 19,
 AFD_SET_DISCONNECT_DATA         = 20,
 AFD_SET_DISCONNECT_OPTIONS      = 21,
 AFD_GET_CONNECT_DATA            = 22,
 AFD_GET_CONNECT_OPTIONS         = 23,
 AFD_GET_DISCONNECT_DATA         = 24,
 AFD_GET_DISCONNECT_OPTIONS      = 25,
 AFD_SET_CONNECT_DATA_SIZE       = 26,
 AFD_SET_CONNECT_OPTIONS_SIZE    = 27,
 AFD_SET_DISCONNECT_DATA_SIZE    = 28,
 AFD_SET_DISCONNECT_OPTIONS_SIZE = 29,
 AFD_GET_INFO                    = 30,
 AFD_SUPER_ACCEPT                = 32,
 AFD_EVENT_SELECT                = 33,
 AFD_ENUM_NETWORK_EVENTS         = 34,
 AFD_DEFER_ACCEPT                = 35,
 AFD_GET_PENDING_CONNECT_DATA    = 41,
 AFD_TRANSPORT_IOCTL             = 47,
 AFD_SUPER_CONNECT               = 49,
 AFD_RECEIVE_MESSAGE             = 51,
 AFD_RIO                         = 70
};

// AFD IOCTLs
SCVR DWORD FSCTL_AFD_BASE  = FILE_DEVICE_NETWORK;
constexpr static _finline DWORD _AFD_CONTROL_CODE(DWORD Function, DWORD Method) {return ((FSCTL_AFD_BASE) << 12 | (Function << 2) | Method);}

SCVR DWORD IOCTL_AFD_BIND                        = _AFD_CONTROL_CODE(AFD_BIND, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_CONNECT                     = _AFD_CONTROL_CODE(AFD_CONNECT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_START_LISTEN                = _AFD_CONTROL_CODE(AFD_START_LISTEN, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_WAIT_FOR_LISTEN             = _AFD_CONTROL_CODE(AFD_WAIT_FOR_LISTEN, METHOD_BUFFERED);
SCVR DWORD IOCTL_AFD_ACCEPT                      = _AFD_CONTROL_CODE(AFD_ACCEPT, METHOD_BUFFERED);
SCVR DWORD IOCTL_AFD_RECV                        = _AFD_CONTROL_CODE(AFD_RECV, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_RECV_DATAGRAM               = _AFD_CONTROL_CODE(AFD_RECV_DATAGRAM, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SEND                        = _AFD_CONTROL_CODE(AFD_SEND, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SEND_DATAGRAM               = _AFD_CONTROL_CODE(AFD_SEND_DATAGRAM, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SELECT                      = _AFD_CONTROL_CODE(AFD_SELECT, METHOD_BUFFERED);
SCVR DWORD IOCTL_AFD_DISCONNECT                  = _AFD_CONTROL_CODE(AFD_DISCONNECT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_SOCK_NAME               = _AFD_CONTROL_CODE(AFD_GET_SOCK_NAME, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_PEER_NAME               = _AFD_CONTROL_CODE(AFD_GET_PEER_NAME, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_TDI_HANDLES             = _AFD_CONTROL_CODE(AFD_GET_TDI_HANDLES, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_INFO                    = _AFD_CONTROL_CODE(AFD_SET_INFO, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_CONTEXT_SIZE            = _AFD_CONTROL_CODE(AFD_GET_CONTEXT_SIZE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_CONTEXT                 = _AFD_CONTROL_CODE(AFD_GET_CONTEXT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_CONTEXT                 = _AFD_CONTROL_CODE(AFD_SET_CONTEXT, METHOD_NEITHER); // 00012047
SCVR DWORD IOCTL_AFD_SET_CONNECT_DATA            = _AFD_CONTROL_CODE(AFD_SET_CONNECT_DATA, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_CONNECT_OPTIONS         = _AFD_CONTROL_CODE(AFD_SET_CONNECT_OPTIONS, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_DISCONNECT_DATA         = _AFD_CONTROL_CODE(AFD_SET_DISCONNECT_DATA, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_DISCONNECT_OPTIONS      = _AFD_CONTROL_CODE(AFD_SET_DISCONNECT_OPTIONS, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_CONNECT_DATA            = _AFD_CONTROL_CODE(AFD_GET_CONNECT_DATA, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_CONNECT_OPTIONS         = _AFD_CONTROL_CODE(AFD_GET_CONNECT_OPTIONS, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_DISCONNECT_DATA         = _AFD_CONTROL_CODE(AFD_GET_DISCONNECT_DATA, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_DISCONNECT_OPTIONS      = _AFD_CONTROL_CODE(AFD_GET_DISCONNECT_OPTIONS, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_CONNECT_DATA_SIZE       = _AFD_CONTROL_CODE(AFD_SET_CONNECT_DATA_SIZE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_CONNECT_OPTIONS_SIZE    = _AFD_CONTROL_CODE(AFD_SET_CONNECT_OPTIONS_SIZE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_DISCONNECT_DATA_SIZE    = _AFD_CONTROL_CODE(AFD_SET_DISCONNECT_DATA_SIZE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_SET_DISCONNECT_OPTIONS_SIZE = _AFD_CONTROL_CODE(AFD_SET_DISCONNECT_OPTIONS_SIZE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_INFO                    = _AFD_CONTROL_CODE(AFD_GET_INFO, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_EVENT_SELECT                = _AFD_CONTROL_CODE(AFD_EVENT_SELECT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_DEFER_ACCEPT                = _AFD_CONTROL_CODE(AFD_DEFER_ACCEPT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_GET_PENDING_CONNECT_DATA    = _AFD_CONTROL_CODE(AFD_GET_PENDING_CONNECT_DATA, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_ENUM_NETWORK_EVENTS         = _AFD_CONTROL_CODE(AFD_ENUM_NETWORK_EVENTS, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_RIO                         = _AFD_CONTROL_CODE(AFD_RIO, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_ACCEPTEX                    = _AFD_CONTROL_CODE(AFD_SUPER_ACCEPT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_TRANSPORT_IOCTL             = _AFD_CONTROL_CODE(AFD_TRANSPORT_IOCTL, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_CONNECTEX                   = _AFD_CONTROL_CODE(AFD_SUPER_CONNECT, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_RECEIVE_MESSAGE             = _AFD_CONTROL_CODE(AFD_RECEIVE_MESSAGE, METHOD_NEITHER);
SCVR DWORD IOCTL_AFD_PARTIAL_DISCONNECT          = _AFD_CONTROL_CODE(AFD_DISCONNECT, METHOD_NEITHER);


// AFD Endpoint information
enum EEP_INFO
{
 AFD_INLINE_MODE             = 0x01,
 AFD_NONBLOCKING_MODE        = 0x02,
 AFD_MAX_SEND_SIZE           = 0x03,
 AFD_SENDS_PENDING           = 0x04,
 AFD_MAX_PATH_SEND_SIZE      = 0x05,
 AFD_RECEIVE_WINDOW_SIZE     = 0x06,
 AFD_SEND_WINDOW_SIZE        = 0x07,
 AFD_CONNECT_TIME            = 0x08,
 AFD_CIRCULAR_QUEUEING       = 0x09,
 AFD_GROUP_ID_AND_TYPE       = 0x0A,
 AFD_REPORT_PORT_UNREACHABLE = 0x0B
};

enum EAFD_FLAGS
{
// Socket types
 AFD_TYPE_STREAM                   = 1,
 AFD_TYPE_DGRAM                    = 2,
                                          
// I/O control modifiers                  
 AFD_NO_FAST_IO                    = 0x0001, // Always fail Fast IO on this request.
 AFD_OVERLAPPED                    = 0x0002, // Overlapped operation.
 AFD_IMMEDIATE                     = 0x0004,
                                          
// Endpoint flags.                        
 AFD_ENDPOINT_FLAG_CONNECTIONLESS  = 0x00000001,
 AFD_ENDPOINT_FLAG_MESSAGEMODE     = 0x00000010,
 AFD_ENDPOINT_FLAG_RAW             = 0x00000100,
 AFD_ENDPOINT_FLAG_REGISTERED_IO   = 0x10000000,

//
// Old AFD_ENDPOINT_TYPE mappings. Flags make things clearer at
// the TDI level and after all Winsock2 switched to provider flags instead of 
// socket type anyway (ATM for example needs connection oriented raw sockets, 
// which can only be reflected by SOCK_RAW+SOCK_STREAM combination which does not exists).
//
 AfdEndpointTypeStream             = 0,
 AfdEndpointTypeDatagram           = (AFD_ENDPOINT_FLAG_CONNECTIONLESS | AFD_ENDPOINT_FLAG_MESSAGEMODE),
 AfdEndpointTypeRaw                = (AFD_ENDPOINT_FLAG_CONNECTIONLESS | AFD_ENDPOINT_FLAG_MESSAGEMODE | AFD_ENDPOINT_FLAG_RAW),
 AfdEndpointTypeSequencedPacket    = (AFD_ENDPOINT_FLAG_MESSAGEMODE),
 AfdEndpointTypeReliableMessage    = (AFD_ENDPOINT_FLAG_MESSAGEMODE),
                                          
//                                        
// New multipoint semantics               
//                                        
 AFD_ENDPOINT_FLAG_MULTIPOINT      = 0x00001000,
 AFD_ENDPOINT_FLAG_CROOT           = 0x00010000,
 AFD_ENDPOINT_FLAG_DROOT           = 0x00100000,
};

enum ETDI_RECV
{
 TDI_RECV_BROADCAST          = 0x00000004, // received TSDU was broadcast.
 TDI_RECV_MULTICAST          = 0x00000008, // received TSDU was multicast.
 TDI_RECV_PARTIAL            = 0x00000010, // received TSDU is not fully presented.
 TDI_RECV_NORMAL             = 0x00000020, // received TSDU is normal data
 TDI_RECV_EXPEDITED          = 0x00000040, // received TSDU is expedited data
 TDI_RECV_PEEK               = 0x00000080, // received TSDU is not released
 TDI_RECV_NO_RESPONSE_EXP    = 0x00000100, // HINT: no back-traffic expected
 TDI_RECV_COPY_LOOKAHEAD     = 0x00000200, // for kernel-mode indications
 TDI_RECV_ENTIRE_MESSAGE     = 0x00000400, // opposite of RECEIVE_PARTIAL
                                      
 //  (for kernel-mode indications)     
 TDI_RECV_AT_DISPATCH_LEVEL  = 0x00000800, // receive indication called at dispatch level											 	    
 TDI_RECV_CONTROL_INFO       = 0x00001000, // Control info is being passed up.
 TDI_RECV_FORCE_INDICATION   = 0x00002000, // reindicate rejected data.
 TDI_RECV_NO_PUSH            = 0x00004000, // complete only when full.
};

enum ETDI_SEND     // USHORT
{
// Options which are used for both SendOptions and ReceiveIndicators.
 TDI_SEND_EXPEDITED            = 0x0020, // TSDU is/was urgent/expedited.
 TDI_SEND_PARTIAL              = 0x0040, // TSDU is/was terminated by an EOR.
 TDI_SEND_NO_RESPONSE_EXPECTED = 0x0080, // HINT: no back traffic expected.
 TDI_SEND_NON_BLOCKING         = 0x0100, // don't block if no buffer space in protocol
 TDI_SEND_AND_DISCONNECT       = 0x0200, // Piggy back disconnect to remote and do not indicate disconnect from remote
};

// TDI address types
enum ETDI_ADDRESS   // USHORT
{
 TDI_ADDRESS_TYPE_UNSPEC             = 0,  // unspecified
 TDI_ADDRESS_TYPE_UNIX               = 1,  // local to host (pipes, portals)
 TDI_ADDRESS_TYPE_IP                 = 2,  // internetwork: UDP, TCP, etc.
 TDI_ADDRESS_TYPE_IMPLINK            = 3,  // arpanet imp addresses
 TDI_ADDRESS_TYPE_PUP                = 4,  // pup protocols: e.g. BSP
 TDI_ADDRESS_TYPE_CHAOS              = 5,  // mit CHAOS protocols
 TDI_ADDRESS_TYPE_NS                 = 6,  // XEROX NS protocols
 TDI_ADDRESS_TYPE_IPX                = 6,  // Netware IPX
 TDI_ADDRESS_TYPE_NBS                = 7,  // nbs protocols
 TDI_ADDRESS_TYPE_ECMA               = 8,  // european computer manufacturers
 TDI_ADDRESS_TYPE_DATAKIT            = 9,  // datakit protocols
 TDI_ADDRESS_TYPE_CCITT              = 10, // CCITT protocols, X.25 etc
 TDI_ADDRESS_TYPE_SNA                = 11, // IBM SNA
 TDI_ADDRESS_TYPE_DECnet             = 12, // DECnet
 TDI_ADDRESS_TYPE_DLI                = 13, // Direct data link interface
 TDI_ADDRESS_TYPE_LAT                = 14, // LAT
 TDI_ADDRESS_TYPE_HYLINK             = 15, // NSC Hyperchannel
 TDI_ADDRESS_TYPE_APPLETALK          = 16, // AppleTalk
 TDI_ADDRESS_TYPE_NETBIOS            = 17, // Netbios Addresses
 TDI_ADDRESS_TYPE_8022               = 18, //
 TDI_ADDRESS_TYPE_OSI_TSAP           = 19, //
 TDI_ADDRESS_TYPE_NETONE             = 20, // for WzMail
 TDI_ADDRESS_TYPE_VNS                = 21, // Banyan VINES IP
 TDI_ADDRESS_TYPE_NETBIOS_EX         = 22, // NETBIOS address extensions
 TDI_ADDRESS_TYPE_IP6                = 23, // IP version 6
 TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX = 24, // WCHAR Netbios address
};

// AFD device name.
#define AFD_DEVICE_NAME                     L"\\Device\\Afd\\Endpoint"
#define AFD_OPEN_PACKET                     "AfdOpenPacketXX"

// AFD RIO registration device name
#define AFD_RIO_DEVICE_NAME                 L"\\Device\\Afd\\RioRegDomain"
#define AFD_RIO_OPEN_PACKET                 "AfdRioRDOpenPacket"

using TDI_STATUS = LONG;
using CONNECTION_CONTEXT = PVOID;


struct AFD_WSABUF
{
 ULONG len;
 PVOID buf;
};
 
struct TDI_ADDRESS_IP 
{
 USHORT sin_port;
 ULONG  in_addr;
 UCHAR  sin_zero[8];
};
 
struct TA_ADDRESS_IP 
{
 LONG  TAAddressCount;
 struct 
 {
  USHORT          AddressLength;
  USHORT          AddressType;
  TDI_ADDRESS_IP  Address[1];
 } Address [1];
};
 
struct TA_ADDRESS 
{
 USHORT  AddressLength;
 USHORT  AddressType;
 UCHAR   Address[1];
};
 
struct TRANSPORT_ADDRESS 
{
 LONG  TAAddressCount;
 TA_ADDRESS  Address[1];
};

struct TDI_REQUEST
{
 union {
  HANDLE AddressHandle;
  CONNECTION_CONTEXT ConnectionContext;
  HANDLE ControlChannel;
 } Handle;
 
 PVOID RequestNotifyObject;
 PVOID RequestContext;
 TDI_STATUS TdiStatus;
};

struct TDI_CONNECTION_INFORMATION
{
 LONG  UserDataLength;        // length of user data buffer
 PVOID UserData;              // pointer to user data buffer
 LONG  OptionsLength;         // length of follwoing buffer
 PVOID Options;               // pointer to buffer containing options
 LONG  RemoteAddressLength;   // length of following buffer
 PVOID RemoteAddress;         // buffer containing the remote address
};

struct TDI_REQUEST_SEND_DATAGRAM
{
 TDI_REQUEST Request;
 TDI_CONNECTION_INFORMATION* SendDatagramInformation;
};

struct NETBUF 
{
 PVOID  pvBuffer;
 ULONG  cbBuffer;
};

struct NETBUFEX 
{
 PVOID  pvBuffer;
 ULONG  cbBuffer;
 ULONG  cbOffset;
};


struct AFD_TRANSPORT_IOCTL_IN
{
 ULONG     Mode;
 ULONG     Level;
 ULONG     Name;
 ULONG     Flag;
 PVOID     InputBuffer;
 ULONGLONG InputLength;
};

struct AFD_OPEN_IN
{
 union {
  FILE_FULL_EA_INFORMATION Ea;
  BYTE                     EaPadding[sizeof(Ea) - alignof(FILE_FULL_EA_INFORMATION) + sizeof(AFD_OPEN_PACKET)];
 };

 ULONG EndpointFlags;
 ULONG GroupID;
 ULONG AddressFamily;
 ULONG SocketType;
 ULONG Protocol;
 ULONG SizeOfTdiName;
 CHAR  TdiName[9];
};

struct AFD_BIND_IN
{
 ULONG ShareType;
 BYTE  AddressData[28];
};

struct AFD_LISTEN_IN
{
 BOOL  UseSAN;
 ULONG Backlog;
 BOOL  UseDelayedAcceptance;
};

struct AFD_CONNECT_IN
{
 BOOLEAN SanActive;
 HANDLE  RootEndpoint;
 HANDLE  ConnectEndpoint;
 BYTE    AddressData[28];
};

struct AFD_SUPER_CONNECT_IN
{
 BOOL   UseSAN;
 ULONG  Tdi;
 USHORT TdiAddressLength;
 BYTE   AddressData[28];
};

struct AFD_SUPER_ACCEPT_IN
{
 BOOLEAN UseSAN;
 BOOLEAN Unk; // TRUE
 HANDLE  AcceptSocket;
 ULONG   ReceiveDataLength;
 ULONG   LocalAddressLength;
 ULONG   RemoteAddressLength;
};

struct AFD_INFORMATION
{
 ULONG InformationType;

 union {
  BOOLEAN       Boolean;
  ULONG         Ulong;
  LARGE_INTEGER LargeInteger;
 } Information;
};

struct AFD_SEND_IN
{
 NETBUF* Buffers;
 ULONG   BufferCount;
 ULONG   AfdFlags;
 ULONG   TdiFlags;
 ULONG   Unused;
};

struct AFD_SEND_DATAGRAM_IN
{
 NETBUF*                    Buffers;
 ULONG                      BufferCount;
 ULONG                      AfdFlags;
 TDI_REQUEST_SEND_DATAGRAM  TdiRequest;
 TDI_CONNECTION_INFORMATION TdiConnInfo;
};

struct AFD_RECV_DATAGRAM_IN
{
 NETBUF* Buffers;
 ULONG   BufferCount;
 ULONG   AfdFlags;
 ULONG   TdiFlags;
 PVOID   Address;
 PULONG  AddressLength;
};

struct AFD_RECV_IN
{
 NETBUF* Buffers;
 ULONG   BufferCount;
 ULONG   AfdFlags;
 ULONG   TdiFlags;
 ULONG   Unused;
};

struct AFD_RECEIVE_MESSAGE_IN
{
 AFD_RECV_DATAGRAM_IN Datagram;
 PVOID                ControlBuffer;
 PULONG               ControlBufferLength;
 PULONG               MsgFlags;
};

struct AFD_TRANSMIT_PACKETS_IN
{
 NETBUFEX* Buffers;
 ULONG     Count;
 ULONG     SendSize;
 ULONG     Flags;
};

struct AFD_PARTIAL_DISCONNECT_IN
{
 ULONG   Flags;
 ULONGLONG Timeout;
};

// Registered I/O Operations
enum EAFD_RIO
{
 AFD_RIO_CQ_REGISTER = 0,
 AFD_RIO_CQ_CLOSE    = 1,
 AFD_RIO_NOTIFY      = 2,
 AFD_RIO_RQ_REGISTER = 3,
 AFD_RIO_REGISTER    = 4,
 AFD_RIO_DEREGISTER  = 5,
 AFD_RIO_TX_POKE     = 6,
 AFD_RIO_RX_POKE     = 7
};

struct AFD_RIO_POKE_IN
{
 ULONG Operation;
};

struct AFD_RIO_REGISTER_IN
{
 ULONG   Operation;
 PVOID64 RegionBaseAddress;
 ULONG   RegionSize;
};

struct AFD_RIO_CQ_REGISTER_IN
{
 ULONG Operation;
 ULONG RingSize;
 ULONG NotificationType;

 union {
  struct
  {
   HANDLE EventHandle;
   BOOL   NotifyReset;
  } Event;

  struct
  {
   HANDLE  PortHandle;
   PVOID64 Context;
   PVOID64 IoStatusBlock;
  } IOCP;
 };

 ULONG   AllocationSize;
 PVOID64 Ring;
};

struct AFD_RIO_RQ_REGISTER_IN
{
 ULONG   Operation;
 ULONG   SendCompletionQueueId;
 ULONG   ReceiveCompletionQueueId;
 ULONG   SendQueueSize;
 ULONG   SendAllocationSize;
 PVOID64 SendRingPtr;
 ULONG   ReceiveQueueSize;
 ULONG   ReceiveAllocationSize;
 PVOID64 ReceiveRingPtr;
 PVOID64 RioDomainHandle;
 PVOID   Context;
};

struct AFD_RIO_NOTIFY_IN
{
 ULONG Operation;
 ULONG CompletionQueueId;
};

//------------------------------------------------------------------------------------------------------------
