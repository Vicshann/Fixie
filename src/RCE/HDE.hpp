
#pragma once

// NOTE: No vectored AVX instructions support (VEX, prefix (0xC4, 0xC5))   // SIMD ?
// UPD: https://github.com/DispatchCode/x64-Instruction-Decoder/
//---------------------------------------------------------------------------
struct NHDE        // X86 
{
// Tables
struct SHDE32
{
 static const uint16 DELTA_OPCODES      = 0x4a;
 static const uint16 DELTA_FPU_REG      = 0xf1;
 static const uint16 DELTA_FPU_MODRM    = 0xf8;
 static const uint16 DELTA_PREFIXES     = 0x130;
 static const uint16 DELTA_OP_LOCK_OK   = 0x1a1;
 static const uint16 DELTA_OP2_LOCK_OK  = 0x1b9;
 static const uint16 DELTA_OP_ONLY_MEM  = 0x1cb;
 static const uint16 DELTA_OP2_ONLY_MEM = 0x1da;

 static inline uint8 Table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00};
};

struct SHDE64
{
 static const uint16 DELTA_OPCODES      = 0x4a;
 static const uint16 DELTA_FPU_REG      = 0xfd;
 static const uint16 DELTA_FPU_MODRM    = 0x104;
 static const uint16 DELTA_PREFIXES     = 0x13c;
 static const uint16 DELTA_OP_LOCK_OK   = 0x1ae;
 static const uint16 DELTA_OP2_LOCK_OK  = 0x1c6;
 static const uint16 DELTA_OP_ONLY_MEM  = 0x1d8;
 static const uint16 DELTA_OP2_ONLY_MEM = 0x1e7;

 static inline uint8 Table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00};

};

template<typename THde> class CHDE
{
// Internal Flags
 static const uint32 C_NONE    = 0x00;
 static const uint32 C_MODRM   = 0x01;
 static const uint32 C_IMM8    = 0x02;
 static const uint32 C_IMM16   = 0x04;
 static const uint32 C_IMM_P66 = 0x10;
 static const uint32 C_REL8    = 0x20;
 static const uint32 C_REL32   = 0x40;
 static const uint32 C_GROUP   = 0x80;
 static const uint32 C_ERROR   = 0xff;

 static const uint32 PRE_ANY   = 0x00;
 static const uint32 PRE_NONE  = 0x01;
 static const uint32 PRE_F2    = 0x02;
 static const uint32 PRE_F3    = 0x04;
 static const uint32 PRE_66    = 0x08;
 static const uint32 PRE_67    = 0x10;
 static const uint32 PRE_LOCK  = 0x20;
 static const uint32 PRE_SEG   = 0x40;
 static const uint32 PRE_ALL   = 0xff;

public:
// Informational Flags about a decoded instruction
 static const uint32 F_MODRM         = 0x00000001;
 static const uint32 F_SIB           = 0x00000002;
 static const uint32 F_IMM8          = 0x00000004;
 static const uint32 F_IMM16         = 0x00000008;
 static const uint32 F_IMM32         = 0x00000010;
 static const uint32 F_IMM64         = 0x00000020;
 static const uint32 F_DISP8         = 0x00000040;
 static const uint32 F_DISP16        = 0x00000080;
 static const uint32 F_DISP32        = 0x00000100;
 static const uint32 F_RELATIVE      = 0x00000200;
 static const uint32 F_2IMM16        = 0x00000800;
 static const uint32 F_ERROR         = 0x00001000;
 static const uint32 F_ERROR_OPCODE  = 0x00002000;
 static const uint32 F_ERROR_LENGTH  = 0x00004000;
 static const uint32 F_ERROR_LOCK    = 0x00008000;
 static const uint32 F_ERROR_OPERAND = 0x00010000;
 static const uint32 F_PREFIX_REPNZ  = 0x01000000;
 static const uint32 F_PREFIX_REPX   = 0x02000000;
 static const uint32 F_PREFIX_REP    = 0x03000000;
 static const uint32 F_PREFIX_66     = 0x04000000;
 static const uint32 F_PREFIX_67     = 0x08000000;
 static const uint32 F_PREFIX_LOCK   = 0x10000000;
 static const uint32 F_PREFIX_SEG    = 0x20000000;
 static const uint32 F_PREFIX_REX    = 0x40000000;
 static const uint32 F_PREFIX_ANY    = 0x7f000000;

 static const uint32 PREFIX_SEGMENT_CS   = 0x2e;
 static const uint32 PREFIX_SEGMENT_SS   = 0x36;
 static const uint32 PREFIX_SEGMENT_DS   = 0x3e;
 static const uint32 PREFIX_SEGMENT_ES   = 0x26;
 static const uint32 PREFIX_SEGMENT_FS   = 0x64;
 static const uint32 PREFIX_SEGMENT_GS   = 0x65;
 static const uint32 PREFIX_LOCK         = 0xf0;
 static const uint32 PREFIX_REPNZ        = 0xf2;
 static const uint32 PREFIX_REPX         = 0xf3;
 static const uint32 PREFIX_OPERAND_SIZE = 0x66;
 static const uint32 PREFIX_ADDRESS_SIZE = 0x67;

//-----------------------------------------------------------------------------------------------------
    uint8 len;
    uint8 p_rep;
    uint8 p_lock;
    uint8 p_seg;
    uint8 p_66;
    uint8 p_67;
    uint8 rex;
    uint8 rex_w;
    uint8 rex_r;
    uint8 rex_x;
    uint8 rex_b; 
    uint8 opcode;
    uint8 opcode2;
    uint8 modrm;       // ModRm field
    uint8 modrm_mod;
    uint8 modrm_reg;
    uint8 modrm_rm;
    uint8 sib;         // Scaled Index Base
    uint8 sib_scale;
    uint8 sib_index;
    uint8 sib_base;
    union {            // Immediate value (a number)
        uint8  imm8;
        uint16 imm16;
        uint32 imm32;
        uint64 imm64;
    } imm;
    union {
        uint8  disp8;
        uint16 disp16;
        uint32 disp32;
    } disp;            // Displacement field
    uint32 flags;

//---------------------------------------------------------------------------
unsigned int Disasm(const void *code)
{
 const bool bHDEx64	= (THde::DELTA_PREFIXES == SHDE64::DELTA_PREFIXES);  // NOTE: The compiler must optimize out this along with every check of this flag because it is static!

    uint8 x, c, *p = (uint8 *)code, cflags, opcode, pref = 0;
    uint8 *ht  = THde::Table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8 op64 = 0;

    memset(this,0,sizeof(CHDE));  // NOTE: Replace with 'for' if it causes some include requirements    // Skip this to gain more speed?

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                this->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                this->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                this->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                this->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                this->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                this->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    this->flags = (uint32)pref << 23;

    if (!pref)pref |= PRE_NONE;

    if (bHDEx64 && ((c & 0xf0) == 0x40)) 
     {
        this->flags |= F_PREFIX_REX;
        if ((this->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)op64++;
        this->rex_r = (c & 7) >> 2;
        this->rex_x = (c & 3) >> 1;
        this->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
     }

    if ((this->opcode = c) == 0x0f) {
        this->opcode2 = c = *p++;
        ht += THde::DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)pref |= PRE_66;
        else pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        this->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16 t;
        t = *(uint16 *)(ht + (cflags & 0x7f));
        cflags = (uint8)t;
        x = (uint8)(t >> 8);
    }

    if (this->opcode2) {
        ht = THde::Table + THde::DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)this->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        this->flags |= F_MODRM;
        this->modrm = c = *p++;
        this->modrm_mod = m_mod = c >> 6;
        this->modrm_rm = m_rm = c & 7;
        this->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))this->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!this->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8 t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = THde::Table + THde::DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = THde::Table + THde::DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)this->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                this->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8 *table_end, op = opcode;
                if (this->opcode2) {
                    ht = THde::Table + THde::DELTA_OP2_LOCK_OK;
                    table_end = ht + THde::DELTA_OP_ONLY_MEM - THde::DELTA_OP2_LOCK_OK;
                } else {
                    ht = THde::Table + THde::DELTA_OP_LOCK_OK;
                    table_end = ht + THde::DELTA_OP2_LOCK_OK - THde::DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))goto no_lock_error;
                        else break;
                    }
                this->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (this->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)goto error_operand;
                    else goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)goto error_operand;
                    else goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)goto error_operand;
                    else goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)goto error_operand;
                    else goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8 *table_end;
            if (this->opcode2) {
                ht = THde::Table + THde::DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(THde::Table) - THde::DELTA_OP2_ONLY_MEM;    
            } else {
                ht = THde::Table + THde::DELTA_OP_ONLY_MEM;
                table_end = ht + THde::DELTA_OP2_ONLY_MEM - THde::DELTA_OP_ONLY_MEM;
            }
            for (; ht < table_end; ht += 2)     // Fix: 'ht != table_end' crash on '41 0F B6 C6  movzx eax, r14b'
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))goto error_operand;
                    else break;
                }
            goto no_error_operand;
        } else if (this->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        this->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)cflags |= C_IMM8;
            else if (opcode == 0xf7)cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)disp_size = 2;
                } else
                    if (m_rm == 5)disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))disp_size <<= 1;
        }

        if ((m_mod != 3 && m_rm == 4) && (bHDEx64 || !(pref & PRE_67))) {	 // 'if(m_mod != 3 && m_rm == 4 && !(pref & PRE_67))' for x32
            this->flags |= F_SIB;
            p++;
            this->sib = c;
            this->sib_scale = c >> 6;
            this->sib_index = (c & 0x3f) >> 3;
            if ((this->sib_base = c & 7) == 5 && !(m_mod & 1))disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                this->flags |= F_DISP8;
                this->disp.disp8 = *p;
                break;
            case 2:
                this->flags |= F_DISP16;
                this->disp.disp16 = *(uint16 *)p;
                break;
            case 4:
                this->flags |= F_DISP32;
                this->disp.disp32 = *(uint32 *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        this->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                this->flags |= F_IMM16 | F_RELATIVE;
                this->imm.imm16 = *(uint16 *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }

	 if(bHDEx64)
	  {
        if (op64) {
            this->flags |= F_IMM64;
            this->imm.imm64 = *(uint64 *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            this->flags |= F_IMM32;
            this->imm.imm32 = *(uint32 *)p;
            p += 4;
        } else goto imm16_ok;
	  }
	   else
	    {
          if (pref & PRE_66) {
            this->flags |= F_IMM16;
            this->imm.imm16 = *(uint16 *)p;
            p += 2;
          } else {
            this->flags |= F_IMM32;
            this->imm.imm32 = *(uint32 *)p;
            p += 4;
          }	
		}
    }


    if (cflags & C_IMM16) {
	  if(bHDEx64)
	   {
      imm16_ok:
        this->flags |= F_IMM16;
        this->imm.imm16 = *(uint16 *)p;
	   }
	    else
		 {
          if (this->flags & F_IMM32) {
            this->flags |= F_IMM16;
            this->disp.disp16 = *(uint16 *)p;
          } else if (this->flags & F_IMM16) {
            this->flags |= F_2IMM16;
            this->disp.disp16 = *(uint16 *)p;
          } else {
            this->flags |= F_IMM16;
            this->imm.imm16 = *(uint16 *)p;
          }		 
		 }
        p += 2;	   
    }
    if (cflags & C_IMM8) {
        this->flags |= F_IMM8;
        this->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        this->flags |= F_IMM32 | F_RELATIVE;
        this->imm.imm32 = *(uint32 *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        this->flags |= F_IMM8 | F_RELATIVE;
        this->imm.imm8 = *p++;
    }

  disasm_done:

    if ((this->len = (uint8)(p-(uint8 *)code)) > 15) {
        this->flags |= F_ERROR | F_ERROR_LENGTH;
        this->len = 15;
    }

    return (unsigned int)this->len;
}
//-----------------------------

// Templated to accept not only pointers
template<typename T> inline static sint32 AddrToRelAddr(T CmdAddr, uint8 CmdLen, T TgtAddr){return -((CmdAddr + CmdLen) - TgtAddr);}       
template<typename T> inline static T      RelAddrToAddr(T CmdAddr, uint8 CmdLen, sint32 TgtOffset){return ((CmdAddr + CmdLen) + TgtOffset);}  
};


using HDE32 = CHDE<SHDE32>;
using HDE64 = CHDE<SHDE64>;
using HDE   = TSW<IsArchX64, CHDE<SHDE64>, CHDE<SHDE32> >::T;

};
//---------------------------------------------------------------------------

